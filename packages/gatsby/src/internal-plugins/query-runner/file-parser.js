// @flow
const fs = require(`fs-extra`)
const crypto = require(`crypto`)
const _ = require(`lodash`)

// Traverse is a es6 module...
import traverse from "babel-traverse"
const getGraphQLTag = require(`babel-plugin-remove-graphql-queries`)
  .getGraphQLTag
const report = require(`gatsby-cli/lib/reporter`)

import type { DocumentNode, DefinitionNode } from "graphql"
import { babelParseToAst } from "../../utils/babel-parse-to-ast"

const apiRunnerNode = require(`../../utils/api-runner-node`)

/**
 * Add autogenerated query name if it wasn't defined by user.
 */
const generateQueryName = ({ def, hash, file }) => {
  if (!def.name || !def.name.value) {
    def.name = {
      value: `${_.camelCase(file)}${hash}`,
      kind: `Name`,
    }
  }
  return def
}

async function parseToAst(filePath, fileStr) {
  let ast

  // Preprocess and attempt to parse source; return an AST if we can, log an
  // error if we can't.
  const transpiled = await apiRunnerNode(`preprocessSource`, {
    filename: filePath,
    contents: fileStr,
  })
  if (transpiled && transpiled.length) {
    for (const item of transpiled) {
      try {
        const tmp = babelParseToAst(item, filePath)
        ast = tmp
        break
      } catch (error) {
        report.error(error)
        continue
      }
    }
    if (ast === undefined) {
      report.error(`Failed to parse preprocessed file ${filePath}`)
    }
  } else {
    try {
      ast = babelParseToAst(fileStr, filePath)
    } catch (error) {
      report.error(
        `There was a problem parsing "${filePath}"; any GraphQL ` +
          `fragments or queries in this file were not processed. \n` +
          `This may indicate a syntax error in the code, or it may be a file type ` +
          `that Gatsby does not know how to parse.`
      )
    }
  }

  return ast
}

const warnForGlobalTag = file =>
  report.warn(
    `Using the global \`graphql\` tag is deprecated, and will not be supported in v3.\n` +
      `Import it instead like:  import { graphql } from 'gatsby' in file:\n` +
      file
  )

async function findGraphQLTags(file, text): Promise<Array<DefinitionNode>> {
  return new Promise((resolve, reject) => {
    parseToAst(file, text)
      .then(ast => {
        let queries = []
        if (!ast) {
          resolve(queries)
          return
        }

        /**
         * A map of graphql documents to unique locations.
         *
         * A graphql document's unique location is made of: 
         *
         *  - the location of the graphql template literal that contains the document, and
         *  - the document's location within the graphql template literal
         *
         * This is used to prevent returning duplicated documents.
         */
        const documentLocations = new WeakMap()

        // Look for queries in <StaticQuery /> elements.
        traverse(ast, {
          TaggedTemplateExpression(path) {
            if (
              (`descendant of query`,
              path?.parentPath?.parentPath?.node?.name?.name !== `query`)
            ) {
              return
            }
            if (
              path.parentPath?.parentPath?.parentPath?.node?.name?.name !==
              `StaticQuery`
            ) {
              return
            }
            const { ast: gqlAst, text, hash, isGlobal } = getGraphQLTag(path)
            if (!gqlAst) return

            if (isGlobal) warnForGlobalTag(file)

            gqlAst.definitions.forEach(def => {
              documentLocations.set(def, `${path.node.start}-${def.loc.start}`)
              generateQueryName({ def, hash, file })
            })

            const definitions = [...gqlAst.definitions].map(d => {
              d.isStaticQuery = true
              d.text = text
              d.hash = hash
              return d
            })
            queries.push(...definitions)
          },
        })

        // Look for exported page queries
        traverse(ast, {
          ExportNamedDeclaration(path, state) {
            path.traverse({
              TaggedTemplateExpression(innerPath) {
                const { ast: gqlAst, isGlobal, hash } = getGraphQLTag(innerPath)
                if (!gqlAst) return

                if (isGlobal) warnForGlobalTag(file)

                gqlAst.definitions.forEach(def => {
                  documentLocations.set(
                    def,
                    `${innerPath.node.start}-${def.loc.start}`
                  )
                  generateQueryName({ def, hash, file })
                })

                queries.push(...gqlAst.definitions)
              },
            })
          },
        })

        // Remove duplicate queries
        const uniqueQueries = _.uniqBy(queries, q => documentLocations.get(q))

        resolve(uniqueQueries)
      })
      .catch(reject)
  })
}

const cache = {}

export default class FileParser {
  async parseFile(file: string): Promise<?DocumentNode> {
    let text
    try {
      text = await fs.readFile(file, `utf8`)
    } catch (err) {
      report.error(`There was a problem reading the file: ${file}`, err)
      return null
    }

    if (text.indexOf(`graphql`) === -1) return null
    const hash = crypto
      .createHash(`md5`)
      .update(file)
      .update(text)
      .digest(`hex`)

    try {
      let astDefinitions =
        cache[hash] || (cache[hash] = await findGraphQLTags(file, text))

      return astDefinitions.length
        ? {
            kind: `Document`,
            definitions: astDefinitions,
          }
        : null
    } catch (err) {
      report.error(
        `There was a problem parsing the GraphQL query in file: ${file}`,
        err
      )
      return null
    }
  }

  async parseFiles(files: Array<string>): Promise<Map<string, DocumentNode>> {
    const documents = new Map()

    return Promise.all(
      files.map(file =>
        this.parseFile(file).then(doc => {
          if (!doc) return
          documents.set(file, doc)
        })
      )
    ).then(() => documents)
  }
}
